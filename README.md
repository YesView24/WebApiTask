# Задание

**Необходимо реализовать API приложение на ASP.NET Core (5 или более поздняя версия). Требования бизнес-логики и ограничения:**
- Формат запроса/ответа должен быть **JSON**.
- Методы API должны быть асинхронными.
- В качестве СУБД необходимо использовать PostgreSQL.
- В качестве ORM необходимо использовать **EntityFrameworkCore**.
- В качестве моделей данных должны использоваться следующие сущности: 
  - **user** (id, login, password, created_date, user_group_id, user_state_id)
  - **user_group** (id, code, description) Возможные значения для code (Admin, User)
  - **user_state** (id, code, description) Возможные значения для code (Active, Blocked).
- Приложение должно позволять добавлять/удалять/получать пользователей. Получить можно как одного, так и всех пользователей (добавление/удаление только по одному). При получении пользователей должна возвращаться полная информация о них (с user_group и user_state).
- Система должна не позволять иметь более одного пользователя с user_group.code = "Admin".
- После успешной регистрации нового пользователя, ему должен быть выставлен статус "Active". Добавление нового пользователя должно занимать 5 сек. За это время при попытке добавления пользователя с таким же login должна возвращаться ошибка. 
- Удаление пользователя должно осуществляться не путём физического удаления из таблицы, а путём выставления статуса "Blocked" у пользователя.
- Допускается добавлять вспомогательные данные в существующие таблицы.

**ОПЦИОНАЛЬНО**

- В качестве способа авторизации следует использовать Basic-авторизацию.
- Реализовать пагинацию для получения нескольких пользователей.
- Написать unit-тесты с помощью xUnit.

# Итоги

**Бэкенд-разработчик (API)**

Спасибо, что выполнили наше тестовое задание!

Мы просили вас написать на фреймворке ASP.Net Core небольшое API-приложение, которое реализует CRUD-операции с пользователями.

Почему задание было именно таким
Нам было важно оценить, как кандидат использует язык C# и платформу .NET для создания API-приложения и насколько умеет взаимодействовать с базой данных при помощи ORM.

**Критерии оценки**
Идеальная работа оценивалась в 50 баллов. Основная часть баллов начислялась за общее качество кода, правильно построенную архитектуру решения, обоснованность выбора библиотек. Каждый опциональный пункт оценивался в 5 баллов.

**Наиболее частые ошибки и недочёты**
• Нет описания реализованной функциональности в проекте GitHub.
• Много бизнес-логики в контроллерах — лучше, чтобы её там вообще не было.
• Не обработаны некоторые кейсы, которые могут вызывать исключения.
• Не прописана строка подключения к базе данных в разделе ConnectionStrings файла appsettings.json.
• Поля сущностей user_group и user_state добавлены в сущность user.
• Не использованы асинхронные методы для доступа к базе данных.
• Не выполнено требование о запрете параллельной регистрации пользователей с одинаковым логином.
• Не использован AutoMapper или другой подобный инструмент для проецирования одной модели на другую.
• Не выполнены какие-то из опциональных заданий.
• Unit-тесты не покрывают некоторые кейсы.

**Рекомендации и итоги**
Приятно удивили кандидаты, которые выходили за рамки технического задания:
• использовали библиотеку MediatR;
• добавили индексы к таблицам базы данных;
• использовали миграции базы данных;
• задействовали кастомные middleware;
• использовали кастомные исключения и их обработчики.

Это хорошие практики, которые мы рекомендуем освоить всем, кто этого ещё не сделал.
К сожалению, никто из кандидатов не использовал паттерн Unit of work, а ведь он заметно упрощает работу с разными репозиториями. Его стоит изучить и применять.
Благодарим вас за вложенные усилия. Продолжайте прокачивать свои навыки и компетенции — возможно, нам ещё представится случай увидеть вас в команде VK.

Желаем успехов!
